<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Alephn&#39;s Blog</title>
  
  <subtitle>Stay hungry, stay foolish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-12T03:13:33.218Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Alephn</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Josephus Problem</title>
    <link href="http://yoursite.com/2019/01/05/Josephus-Problem/"/>
    <id>http://yoursite.com/2019/01/05/Josephus-Problem/</id>
    <published>2019-01-05T06:42:32.000Z</published>
    <updated>2019-01-12T03:13:33.218Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Josephus-Problem"><a href="#Josephus-Problem" class="headerlink" title="Josephus Problem"></a>Josephus Problem</h1><h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><blockquote><p>In <a href="https://en.wikipedia.org/wiki/Computer_science" target="_blank" rel="noopener">computer science</a> and <a href="https://en.wikipedia.org/wiki/Mathematics" target="_blank" rel="noopener">mathematics</a>, the <strong>Josephus problem</strong> (or <strong>Josephus permutation</strong>) is a theoretical problem related to a certain <a href="https://en.wikipedia.org/wiki/Counting-out_game" target="_blank" rel="noopener">counting-out game</a>.</p><p>People are standing in a <a href="https://en.wikipedia.org/wiki/Circle" target="_blank" rel="noopener">circle</a> waiting to be executed. Counting begins at a specified point in the circle and proceeds around the circle in a specified direction. After a specified number of people are skipped, the next person is executed. The procedure is repeated with the remaining people, starting with the next person, going in the same direction and skipping the same number of people, until only one person remains, and is freed.</p><p>The problem — given the number of people, starting point, direction, and number to be skipped — is to choose the position in the initial circle to avoid execution</p><p><a href="https://en.wikipedia.org/wiki/Josephus_problem" target="_blank" rel="noopener">more info</a></p><p>约瑟夫是公元一世纪著名的历史学家。在罗马人占领乔塔帕特后，39 个犹太人与约瑟夫及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人俘虏，于是决定了一个流传千古的自杀方式，41个人排成一个圆圈，由第1个人开始报数，每报到第3人该人就必须自杀，然后再由下一个人重新报数，直到所有人都自杀身亡为止。</p></blockquote><p>Josephus problem是一个非常有意思的问题，理解起来很简单，但是要解决却不是太容易。以前在程序课上接触过这个问题，当时的解决方法非常暴力，直接模拟整个游戏过程来得到最终答案。最近读到《具体数学》再次接触到了这个问题，书中的解法确有让人拍案而起的欲望。下面从该问题最基础的类型说起，一步一步解释书中的解法。</p><h2 id="基础问题"><a href="#基础问题" class="headerlink" title="基础问题"></a>基础问题</h2><ul><li><p>现有一个n节点的圆圈，且从1到n有序排列。从1开始计数，每隔一个节点去除一个节点，问最后剩下的节点（下面简称幸存者）序号是多少？</p><p><img src="/2019/01/05/Josephus-Problem/josephus example.png" alt="josephus example"></p><p style="background-color:powderblue;font-size:15px;">Figure 1 </p></li><li><p>要解决这个问题，可以从递归的角度来考虑，这一点在图1中有很直观的表达。针对我们的问题，我们要求解的是幸存者序号，不妨表示为$f(n)$，根据n的奇偶性可以得到下面的关系</p></li></ul><script type="math/tex; mode=display">\begin{align}  问题1  \begin{cases}  f(1) &=& 1\\  f(2n) &=& 2·f(n)-1\\  f(2n+1) &=& 2·f(n)+1\\  \end{cases}  \end{align}</script><p>  现在的问题是如何根据上面的关系求出$f(n)$的表达式。首先不妨从一些简单的例子观察一下规律</p><div class="table-container"><table><thead><tr><th>n</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th></tr></thead><tbody><tr><td>$f$</td><td>1</td><td>1</td><td>2</td><td>1</td><td>2</td><td>3</td><td>4</td><td>1</td></tr></tbody></table></div><p>  看起来是有一定规律的，写成下面这样也许更清晰</p><div class="table-container"><table><thead><tr><th>n</th><th>$2^0$</th><th>$2^1$</th><th>$2^1+1$</th><th>$2^2$</th><th>$2^2+1$</th><th>$2^2+2$</th><th>$2^2+3$</th><th>$2^3$</th></tr></thead><tbody><tr><td>$f$</td><td>1</td><td>1</td><td>3</td><td>1</td><td>3</td><td>5</td><td>7</td><td>1</td></tr></tbody></table></div><p>  简单的归纳就是$f(n) = 2l+1, n=2^m+l$，下面用数学归纳法来证明这一结论</p><script type="math/tex; mode=display">  \begin{align}  &需要证明：对于n=2^m+l, f(n)=2l+1,其中0=<l<2^m\\  &证明：\\  &m = 0, n = 1\ 时f(1) = 2·0+1,结论成立\\  &假设m=k时结论成立,下正m=k+1时结论仍然成立\\  &m=k+1时, 2^{k+1}=<n<2^{k+2}\\  &当n为偶数时, n = 2^{k+1} + l, l为偶数, l=2l^*\\  &f(n) = 2f(2^k+l^*)-1=2(2l^*+1)-1=2l+1\\  &n为奇数时类似,不难得出当m=k+1时结论仍成立，得证  \end{align}</script><p>  现在我们已经有了$f(n)$的显式表达，不过更令人兴奋的是我们可以用一种更为简洁美观的方式来表达这一结果。</p><script type="math/tex; mode=display">\begin{align}  &首先将n=2^m+l表示为二进制的形式, n=(b_mb_{m-1}...b_1b_0)_2,即n=b_m2^m+..+b_0\\  &其中b_m=1, l=(b_{m-1}b_{m-2}...b1b0)_2\\  &2l+1=2(b_{m-1}b_{m-2}...b1b0)_2+1=(b_{m-1}b_{m-2}...b_1b_0b_m)_2\\  &f((b_mb_{m-1}...b_1b_0)_2)=(b_{m-1}b_{m-2}...b_1b_0b_m)_2\\  &这样计算f(n)就可以用计算机最喜欢的移位运算了  \end{align}</script><p>  第一次看到上面的结果，我确实很开心，感觉这种形式很漂亮。不过让我更惊喜的是不仅在基础情况下，在复杂的情况下我们也可以利用上面的形式来求解递归式。</p><p>为了叙述简便，把递归式中$f(dn)$ 中d称为step，下面一般化以d为基础</p><h2 id="问题一般化"><a href="#问题一般化" class="headerlink" title="问题一般化"></a>问题一般化</h2><h3 id="Step-2"><a href="#Step-2" class="headerlink" title="Step=2"></a>Step=2</h3><ul><li>step=2与上面解决的问题有很大重合，问题形式化表达如下<script type="math/tex; mode=display">\begin{align}问题2  \begin{cases}  f(1) &=& \alpha\\  f(2n+j) &=& 2·f(n)+\beta_j \ \ (j=0, 1)  \end{cases}  \end{align}</script>问题2与问题1的唯一区别是对$\alpha,\beta_j$进行了一般化，在问题1中$\alpha=1,\beta_0=-1, \beta_1=1$</li></ul><script type="math/tex; mode=display">  \begin{align}  &首先将n=2^m+l表示为二进制的形式, n=(b_mb_{m-1}...b_1b_0)_2,即n=b_m2^m+..+b_0\\  &n = 1, f(1) = \alpha, f((1)_2) = \alpha\\  &对j进行分类\\  &j=0时l=2·l^*\\  &f(n)=2f(2^{m-1}+l*)+\beta_0\\  &f((b_mb_{m-1}...b_1b_0)_2)=2f((b_mb_{m-1}...b_1)_2)+\beta_0\\  &f((b_mb_{m-1}...b_1b_0)_2)=2f(b_mb_{m-1}...b_1)_2)+\beta_{b_0}\\  &j=1  时类似，递归可以得到如下结果\\  &f((b_mb_{m-1}...b_1b_0)_2)=2^m\alpha+2^{m-1}\beta_{b_{m-1}}+...+\beta_{b_0}\\  &f((b_mb_{m-1}...b_1b_0)_2)=(\alpha\beta_{b_{m-1}}...\beta_{b_0})_2  \end{align}</script><p>  可以看到，我们再次利用二进制形式写出了任意$f(n)$的解表达式。不过需要注意的是这里的二进制与一般意义上的二进制表达式有一定区别，这里在某个二进制位上的数值可能取0，1之外的值</p><h3 id="Step-d-d-gt-1"><a href="#Step-d-d-gt-1" class="headerlink" title="Step = d, d&gt;1"></a>Step = d, d&gt;1</h3><ul><li>这里对step一般化，取任意大于1的整数值，问题形式化表达如下<script type="math/tex; mode=display">\begin{align}问题3  \begin{cases}  f(j) &=& \alpha_j\ (0<j<d)\\   f(dn+j) &=& cf(n)+\beta_j \ \ (0=<j<d)  \end{cases}  \end{align}</script></li></ul><script type="math/tex; mode=display">\begin{align}&首先将n=2^m+l表示为d进制的形式, n=(b_mb_{m-1}...b_1b_0)_d,即n=b_md^m+..+b_0\\&n = j, f(j) = \alpha_j, f((j)_d) = \alpha_j, \ (0<j<d)\\&n=(b_mb_{m-1}...b_1b_0)_d, b_0=j\\&f((b_mb_{m-1}...b_1b_0)_d)=2f((b_mb_{m-1}...b_1)_2)+\beta_0\\&f((b_mb_{m-1}...b_1b_0)_d)=cf(b_mb_{m-1}...b_1)_d)+\beta_{b_0}\\&f((b_mb_{m-1}...b_1b_0)_d)=c^m\alpha_{b_m}+c^{m-1}\beta_{b_{m-1}}+...+\beta_{b_0}\\&f((b_mb_{m-1}...b_1b_0)_d)=(\alpha_{b_m}\beta_{b_{m-1}}...\beta_{b_0})_c\end{align}</script><ul><li>问题3是最一般化的形式，从最后结果来看，问题3中定义的递归表达式将一个d进制的数映射到了另一个c进        制的数</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Josephus-Problem&quot;&gt;&lt;a href=&quot;#Josephus-Problem&quot; class=&quot;headerlink&quot; title=&quot;Josephus Problem&quot;&gt;&lt;/a&gt;Josephus Problem&lt;/h1&gt;&lt;h2 id=&quot;问题引入&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="Mathematics" scheme="http://yoursite.com/tags/Mathematics/"/>
    
      <category term="Concrete Mathematics" scheme="http://yoursite.com/tags/Concrete-Mathematics/"/>
    
      <category term="Recurrent Problem" scheme="http://yoursite.com/tags/Recurrent-Problem/"/>
    
  </entry>
  
  <entry>
    <title>BurnSide&#39;s Lemma</title>
    <link href="http://yoursite.com/2018/12/30/BurnSide-Lemma/"/>
    <id>http://yoursite.com/2018/12/30/BurnSide-Lemma/</id>
    <published>2018-12-30T00:35:41.000Z</published>
    <updated>2019-01-05T08:01:32.631Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Burnside’s-lemma"><a href="#Burnside’s-lemma" class="headerlink" title="Burnside’s lemma"></a>Burnside’s lemma</h1><h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><ul><li><p>利用三种颜色给一个正三边形的顶点着色，在考虑图案重复的情况下总共有多少不同的着色方法？</p></li><li><p>上面的着色问题是一类计数问题，在计数的过程中由于需要考虑到去除重复的元素，所以问题会显得比较复杂</p><p><img src="/2018/12/30/BurnSide-Lemma/colour_symmetries.png"></p><p style="background-color:powderblue;font-size:15px;">Figure 1 </p><p>以上图为例，六种三角形的着色实际是等价的，只能算一种着色方式。</p></li></ul><h2 id="Burnside’s-lemma定义"><a href="#Burnside’s-lemma定义" class="headerlink" title="Burnside’s lemma定义"></a>Burnside’s lemma定义</h2><ul><li><blockquote><p><strong>Burnside’s lemma</strong>, sometimes also called <strong>Burnside’s counting theorem</strong>, the <strong>Cauchy–Frobenius lemma</strong>,<strong>orbit-counting theorem</strong>, or <strong>The Lemma that is not Burnside’s</strong> , is a result in <a href="https://en.wikipedia.org/wiki/Group_theory" target="_blank" rel="noopener">group theory</a> which is often useful in taking account of <a href="https://en.wikipedia.org/wiki/Symmetry" target="_blank" rel="noopener">symmetry</a> when counting mathematical objects.In the following, let <em>G</em> be a <a href="https://en.wikipedia.org/wiki/Finite_set" target="_blank" rel="noopener">finite</a> <a href="https://en.wikipedia.org/wiki/Group_(mathematics" target="_blank" rel="noopener">group</a>) that <a href="https://en.wikipedia.org/wiki/Group_action" target="_blank" rel="noopener">acts</a> on a <a href="https://en.wikipedia.org/wiki/Set_(mathematics" target="_blank" rel="noopener">set</a>) <em>X</em>. For each <em>g</em> in <em>G</em> let <em>Xg</em> denote the set of <a href="https://en.wikipedia.org/wiki/Element_(mathematics" target="_blank" rel="noopener">elements</a>) in <em>X</em> that are <a href="https://en.wikipedia.org/wiki/Fixed_point_(mathematics" target="_blank" rel="noopener">fixed by</a>) <em>g</em> (also said to be left <a href="https://en.wikipedia.org/wiki/Invariant_(mathematics" target="_blank" rel="noopener">invariant</a>) by <em>g</em>), i.e. <em>$X^g $</em> = { <em>x</em> ∈ <em>X</em> | <em>g</em>.<em>x</em> = <em>x</em> }. Burnside’s lemma asserts the following formula for the number of <a href="https://en.wikipedia.org/wiki/Orbit_(group_theory" target="_blank" rel="noopener">orbits</a>), denoted |<em>X</em>/<em>G</em>|</p>$$|X/G|={\frac  {1}{|G|}}\sum _{{g\in G}}|X^{g}|$$<p><a href="https://en.wikipedia.org/wiki/Burnside%27s_lemma" target="_blank" rel="noopener">Burnside’s lemma</a></p></blockquote></li><li><p>上面给出了Burnside’s lemma的定义，其具体的证明过程可参考给出的链接。利用Burnside’s lemma我们现在可以来试着解决一开始给出的着色问题了。</p></li></ul><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><ul><li>着色问题的形式化定义<ul><li>$X :=\{不考虑重复的所有着色图案\}$</li><li>$G :=\{对任一图案的所有变换\}$</li><li>$|X/G| := 所有不重复的着色方式总数$</li></ul></li><li>$G$ 代表了对图案的变换方式，图1实际上就包含了对三角形的所有变换方式。其中旋转变换有三种，对称变换有三种。以旋转$\frac 2 3 \pi$为例，$X^g = \{x | colorA = colorB = colorC\}$  只有满足条件的着色图案才有$g.x=x$ ，不难计算这类着色方式有三种，$3^1$</li><li>对于上述的三色三角形问题，总共有 $\frac 1 6(3^3+2·3^1+3·3^2) = 10$种着手方式</li></ul><h2 id="问题一般化"><a href="#问题一般化" class="headerlink" title="问题一般化"></a>问题一般化</h2><ul><li><p>利用上述定理可以解决任意$(n, m)$着色问题，其中n代表正多边形的顶点数，m代表颜色数。</p></li><li><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/12/30/BurnSide-Lemma/question.png" alt="question" title="">                </div>                <div class="image-caption">question</div>            </figure><p style="background-color:powderblue;font-size:15px;">Figure 2 </p><p>图2便是一个一般化的正多边形的着色问题。</p></li><li><p>解决这个一般化问题可以从两个部分入手</p><ul><li><p>旋转变换对应的$X^g$: 对于n边形，旋转变换共有n种，旋转度数从$0-2\pi$,关键问题是如何计算每一种旋转变换的着色数量。下面尝试将问题形式化</p><script type="math/tex; mode=display">\begin{align}&对于任一旋转变换d(0=< d < n),顶点可分为以下几类\\&\Phi _0 = \{0, d, 2d, ...\}\\&\Phi _1 = \{1, d+1, 2d+1, ...\}\\&...\\&\Phi _i = \{i, d+i, 2d+i, ...\}\\&对于任一顶点x, x属于并仅属于某一\Phi\\&对任一(x_1,x_2)属于\Phi_j, x_1 = x_2+kd\ (mod\ n)\\&对于同一\Phi中的顶点，颜色应该一致，总的着色数有m^{i+1}\end{align}</script></li><li><p>对称变换较容易，考虑奇偶分类处理即可</p></li></ul></li><li><p>Python代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> step <span class="keyword">in</span> range(n):</span><br><span class="line">    count = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        count[i] = <span class="number">0</span></span><br><span class="line">    uncount, ucNow, ucAll = <span class="keyword">True</span>, <span class="number">0</span>, []</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        ucFirst, orbitSet = <span class="number">0</span>, []</span><br><span class="line">        <span class="keyword">while</span> ucFirst != n:</span><br><span class="line">            <span class="keyword">if</span> count[ucFirst] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ucFirst += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> ucFirst == n:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        i = ucFirst</span><br><span class="line">        <span class="keyword">while</span> count[i] != <span class="number">1</span>:</span><br><span class="line">            orbitSet.append(i)</span><br><span class="line">            count[i] = <span class="number">1</span></span><br><span class="line">            i = (i+step)%n </span><br><span class="line">        ucNow += <span class="number">1</span></span><br><span class="line">//模拟得出所有的orbitSet集合，例如n=<span class="number">10</span>，step=<span class="number">2</span>时，orbitSet集合为</span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure><p>通过证明可以得到$|\Phi| = grd(n, d)$, 这样就不用计算每个集合的元素，直接可以得到集合个数</p><p>对称变换太简单，这里不详细说明。</p></li><li><p><a href="https://codeforces.com/blog/entry/51272" target="_blank" rel="noopener">其它类似问题</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Burnside’s-lemma&quot;&gt;&lt;a href=&quot;#Burnside’s-lemma&quot; class=&quot;headerlink&quot; title=&quot;Burnside’s lemma&quot;&gt;&lt;/a&gt;Burnside’s lemma&lt;/h1&gt;&lt;h2 id=&quot;问题引入&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="Mathematics" scheme="http://yoursite.com/tags/Mathematics/"/>
    
      <category term="GroupTheory" scheme="http://yoursite.com/tags/GroupTheory/"/>
    
      <category term="CountProblem" scheme="http://yoursite.com/tags/CountProblem/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
</feed>
