<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Alephn&#39;s Blog</title>
  
  <subtitle>Stay hungry, stay foolish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-06-29T01:03:07.153Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Alephn</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>numpy向量化操作</title>
    <link href="http://yoursite.com/2019/06/29/numpy%E5%90%91%E9%87%8F%E5%8C%96%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2019/06/29/numpy向量化操作/</id>
    <published>2019-06-29T00:48:14.000Z</published>
    <updated>2019-06-29T01:03:07.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="numpy向量化操作"><a href="#numpy向量化操作" class="headerlink" title="numpy向量化操作"></a>numpy向量化操作</h1><p>本文记录一些常见的利用numpy向量化操作提高运行速度的方法</p><a id="more"></a><h2 id="0-1矩阵的生成"><a href="#0-1矩阵的生成" class="headerlink" title="0\1矩阵的生成"></a>0\1矩阵的生成</h2><ul><li><p>在机器学习中，如果是二分类问题，最后需要将概率矩阵转化为0/1矩阵，如果使用for循环就没有办法利用到numpy的优势</p></li><li><p>下面是几个例子</p></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_ypre</span><span class="params">(A, dim)</span>:</span> </span><br><span class="line">    y_pre = np.zeros((<span class="number">1</span>, dim))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(dim):</span><br><span class="line">        <span class="keyword">if</span> A[<span class="number">0</span>, i] &gt; <span class="number">0.5</span>:</span><br><span class="line">            y_pre[<span class="number">0</span>, i] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> y_pre</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_ypre_vectorize_1</span><span class="params">(A, dim)</span>:</span></span><br><span class="line">    y_pre = np.where(A &lt; <span class="number">0.5</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> y_pre     </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_ypre_vectorize_2</span><span class="params">(A, dim)</span>:</span></span><br><span class="line">    y_pre = np.floor(A + <span class="number">0.5</span>)</span><br><span class="line">    <span class="keyword">return</span> y_pre</span><br></pre></td></tr></table></figure></li><li><p><code>get_ypre</code>函数利用for循环遍历需要转换为0/1矩阵的A矩阵，<code>get_ypre_vectorize_1</code>和<code>get_ypre_vectorize_2</code>分别利用numpy的<a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.where.html" target="_blank" rel="noopener">np.where</a>和<a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.floor.html" target="_blank" rel="noopener">np.floor</a>进行向量化处理，运行时间如下所示</p></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dim = <span class="number">10</span>**<span class="number">7</span></span><br><span class="line">A = np.random.rand(<span class="number">1</span>, dim)</span><br><span class="line">timeit(<span class="keyword">lambda</span>:get_ypre(A, dim), number=<span class="number">1</span>)</span><br><span class="line">out : <span class="number">2.667440585035365</span></span><br><span class="line">timeit(<span class="keyword">lambda</span>:get_ypre_vectorize_1(A, dim), number=<span class="number">1</span>)</span><br><span class="line">out : <span class="number">0.06458032497903332</span></span><br><span class="line">timeit(<span class="keyword">lambda</span>:get_ypre_vectorize_1(A, dim), number=<span class="number">1</span>)</span><br><span class="line">out : <span class="number">0.06309162796242163</span></span><br></pre></td></tr></table></figure></li><li><p>可以看到提升效果比较明显</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;numpy向量化操作&quot;&gt;&lt;a href=&quot;#numpy向量化操作&quot; class=&quot;headerlink&quot; title=&quot;numpy向量化操作&quot;&gt;&lt;/a&gt;numpy向量化操作&lt;/h1&gt;&lt;p&gt;本文记录一些常见的利用numpy向量化操作提高运行速度的方法&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>sklearn common usage</title>
    <link href="http://yoursite.com/2019/06/23/sklearn-common-usage/"/>
    <id>http://yoursite.com/2019/06/23/sklearn-common-usage/</id>
    <published>2019-06-23T01:41:02.000Z</published>
    <updated>2019-06-24T07:11:33.899Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sklearn-common-usage"><a href="#sklearn-common-usage" class="headerlink" title="sklearn common usage"></a>sklearn common usage</h1><p>本文主要记录使用sklearn中遇到的一些常见用法</p><p><a href="https://scikit-learn.org/stable/" target="_blank" rel="noopener">scikit-learn</a></p><h2 id="Preprocessing"><a href="#Preprocessing" class="headerlink" title="Preprocessing"></a><a href="https://scikit-learn.org/stable/modules/preprocessing.html#preprocessing" target="_blank" rel="noopener">Preprocessing</a></h2><ul><li><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.impute.SimpleImputer.html#sklearn.impute.SimpleImputer" target="_blank" rel="noopener">SimpleImputer</a></p><ul><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.impute <span class="keyword">import</span> SimpleImputer</span><br><span class="line">imp_mean = SimpleImputer(missing_values=np.nan, strategy=<span class="string">'mean'</span>)</span><br><span class="line">imp_mean.fit_transform([[<span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, np.nan, <span class="number">6</span>], [<span class="number">10</span>, <span class="number">5</span>, <span class="number">9</span>]])</span><br></pre></td></tr></table></figure></li></ul></li><li><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html#sklearn.preprocessing.OneHotEncoder" target="_blank" rel="noopener">OneHotEncoder</a>&amp;<a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.LabelEncoder.html#sklearn.preprocessing.LabelEncoder" target="_blank" rel="noopener">LabelEncoder</a></p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.preprocessing import OneHotEncoder</span><br><span class="line">enc = OneHotEncoder(handle_unknown=&apos;ignore&apos;)</span><br><span class="line">X = [[&apos;Male&apos;, 1], [&apos;Female&apos;, 3], [&apos;Female&apos;, 2]]</span><br><span class="line">enc.fit_transform(X)</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.preprocessing import LabelEncoder</span><br><span class="line">le = LabelEncoder()</span><br><span class="line">le.fit_transform([1, 2, 2, 6])</span><br></pre></td></tr></table></figure></li><li><p>一般在使用onehot之前先使用labelencoder进行处理，见<a href="https://towardsdatascience.com/encoding-categorical-features-21a2651a065c" target="_blank" rel="noopener">例子1</a>,<a href="https://www.ritchieng.com/machinelearning-one-hot-encoding/" target="_blank" rel="noopener">例子2</a></p></li></ul></li></ul><h2 id="Model-selection-and-evaluation"><a href="#Model-selection-and-evaluation" class="headerlink" title="Model selection and evaluation"></a><a href="https://scikit-learn.org/stable/model_selection.html#model-selection" target="_blank" rel="noopener">Model selection and evaluation</a></h2><ul><li><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html" target="_blank" rel="noopener">train_test_split</a></p><ul><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.33</span>, random_state=<span class="number">42</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.StandardScaler.html#sklearn.preprocessing.StandardScaler" target="_blank" rel="noopener">StandardScaler</a></p><ul><li><blockquote><p>The standard score of a sample <a href="https://scikit-learn.org/stable/glossary.html#term-x" target="_blank" rel="noopener">x</a> is calculated as:</p><p>z = (x - u) / s</p></blockquote></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line">scaler = StandardScaler()</span><br><span class="line">scaler.fit_transform(X)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Regression"><a href="#Regression" class="headerlink" title="Regression"></a><a href="https://scikit-learn.org/stable/supervised_learning.html#supervised-learning" target="_blank" rel="noopener">Regression</a></h2><ul><li><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LinearRegression.html#sklearn.linear_model.LinearRegression" target="_blank" rel="noopener"><code>LinearRegression</code></a></p><ul><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line">reg = LinearRegression().fit(X, y)</span><br><span class="line">reg.predict(np.array([[<span class="number">3</span>, <span class="number">5</span>]]))</span><br></pre></td></tr></table></figure></li><li></li></ul></li><li></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;sklearn-common-usage&quot;&gt;&lt;a href=&quot;#sklearn-common-usage&quot; class=&quot;headerlink&quot; title=&quot;sklearn common usage&quot;&gt;&lt;/a&gt;sklearn common usage&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Stationarity of time series</title>
    <link href="http://yoursite.com/2019/06/15/Stationarity-of-time-series/"/>
    <id>http://yoursite.com/2019/06/15/Stationarity-of-time-series/</id>
    <published>2019-06-15T02:22:40.000Z</published>
    <updated>2019-06-15T03:01:26.275Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Stationarity-of-time-series"><a href="#Stationarity-of-time-series" class="headerlink" title="Stationarity of time series"></a>Stationarity of time series</h1><p>本文主要记录学习过程中关于时间序列平稳性的一些相关内容，包括平稳性的定义以及检测</p><h2 id="平稳性定义"><a href="#平稳性定义" class="headerlink" title="平稳性定义"></a>平稳性定义</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/06/15/Stationarity-of-time-series/平稳性.png" alt="平稳性" title="">                </div>                <div class="image-caption">平稳性</div>            </figure><p>在实际应用过程中，我们一般通过弱平稳来检测平稳性</p><p>上图来自<a href="https://www.zhihu.com/question/21982358" target="_blank" rel="noopener">知乎</a></p><h2 id="平稳性检测"><a href="#平稳性检测" class="headerlink" title="平稳性检测"></a>平稳性检测</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> statsmodels.tsa.stattools <span class="keyword">import</span> adfuller</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_stationarity</span><span class="params">(timeseries)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#Determing rolling statistics</span></span><br><span class="line">    rolmean = timeseries.rolling(<span class="number">12</span>).mean()</span><br><span class="line">    rolstd = timeseries.rolling(<span class="number">12</span>).std()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#Plot rolling statistics:</span></span><br><span class="line">    orig = plt.plot(timeseries, color=<span class="string">'blue'</span>,label=<span class="string">'Original'</span>)</span><br><span class="line">    mean = plt.plot(rolmean, color=<span class="string">'red'</span>, label=<span class="string">'Rolling Mean'</span>)</span><br><span class="line">    std = plt.plot(rolstd, color=<span class="string">'black'</span>, label = <span class="string">'Rolling Std'</span>)</span><br><span class="line">    plt.legend(loc=<span class="string">'best'</span>)</span><br><span class="line">    plt.title(<span class="string">'Rolling Mean &amp; Standard Deviation'</span>)</span><br><span class="line">    plt.show(block=<span class="keyword">False</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#Perform Dickey-Fuller test:</span></span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'Results of Dickey-Fuller Test:'</span>)</span><br><span class="line">    dftest = adfuller(timeseries, autolag=<span class="string">'AIC'</span>)</span><br><span class="line">    dfoutput = pd.Series(dftest[<span class="number">0</span>:<span class="number">4</span>], index=[<span class="string">'Test Statistic'</span>,<span class="string">'p-value'</span>,<span class="string">'#Lags Used'</span>,<span class="string">'Number of Observations Used'</span>])</span><br><span class="line">    <span class="keyword">for</span> key,value <span class="keyword">in</span> dftest[<span class="number">4</span>].items():</span><br><span class="line">        dfoutput[<span class="string">'Critical Value (%s)'</span>%key] = value</span><br><span class="line">    <span class="keyword">print</span> (dfoutput)</span><br><span class="line"></span><br><span class="line">test_stationarity(ts)</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/06/15/Stationarity-of-time-series/平稳性检测.png" alt="平稳性检测" title="">                </div>                <div class="image-caption">平稳性检测</div>            </figure><p>利用adfuller检测时间序列平稳性，当Test Statistic小于某个Critical Value时则认为在该置信下认为时间序列平稳</p><h2 id="时间序列平稳化"><a href="#时间序列平稳化" class="headerlink" title="时间序列平稳化"></a>时间序列平稳化</h2><p><a href="https://www.analyticsvidhya.com/blog/2016/02/time-series-forecasting-codes-python/" target="_blank" rel="noopener">差分&amp;去除趋势</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Stationarity-of-time-series&quot;&gt;&lt;a href=&quot;#Stationarity-of-time-series&quot; class=&quot;headerlink&quot; title=&quot;Stationarity of time series&quot;&gt;&lt;/a&gt;Stati
      
    
    </summary>
    
    
      <category term="Statics" scheme="http://yoursite.com/tags/Statics/"/>
    
  </entry>
  
  <entry>
    <title>pandas common usage</title>
    <link href="http://yoursite.com/2019/06/10/pandas-common-usage/"/>
    <id>http://yoursite.com/2019/06/10/pandas-common-usage/</id>
    <published>2019-06-10T11:24:30.000Z</published>
    <updated>2019-06-24T07:11:35.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pandas-common-usage"><a href="#pandas-common-usage" class="headerlink" title="pandas common usage"></a>pandas common usage</h1><blockquote><p><em>pandas</em> is an open source, BSD-licensed library providing high-performance, easy-to-use data structures and data analysis tools for the <a href="https://www.python.org/" target="_blank" rel="noopener">Python</a> programming language.</p><p><a href="https://pandas.pydata.org" target="_blank" rel="noopener">pandas</a></p></blockquote><p>本文主要记录在实践中遇到的一些常见的用法</p><h2 id="一些说明"><a href="#一些说明" class="headerlink" title="一些说明"></a>一些说明</h2><ul><li>df表示<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html" target="_blank" rel="noopener">pandas.DataFrame</a></li></ul><h2 id="dataFrame"><a href="#dataFrame" class="headerlink" title="dataFrame"></a>dataFrame</h2><ul><li><p><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.rolling.html#pandas.DataFrame.rolling" target="_blank" rel="noopener">rolling</a></p><ul><li><blockquote><p>为了提升数据的准确性，将某个点的取值扩大到包含这个点的一段区间，用区间来进行判断，这个区间就是窗口。移动窗口就是窗口向一端滑行，默认是从右往左</p></blockquote></li><li><p>rolling返回的类可以进行很多数值操作，例如<figure class="highlight plain"><figcaption><span>std(), sum()```,这些均是dataFrame包含的方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- [dropna](https://pandas.pydata.org/pandas-docs/version/0.21/generated/pandas.DataFrame.dropna.html#pandas.DataFrame.dropna)</span><br><span class="line"></span><br><span class="line">  - 去除空值</span><br><span class="line"></span><br><span class="line">- [Merge, join, and concatenate](https://pandas.pydata.org/pandas-docs/stable/user_guide/merging.html)</span><br><span class="line"></span><br><span class="line">  - 对多个dataframe进行合并操作，包括行、列数据</span><br><span class="line"></span><br><span class="line">- [duplicated](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.duplicated.html)</span><br><span class="line"></span><br><span class="line">  - 判断重复数据</span><br><span class="line"></span><br><span class="line">- [drop_duplicates](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.drop_duplicates.html)</span><br><span class="line"></span><br><span class="line">  - ​去除重复数据</span><br><span class="line"></span><br><span class="line">- [group_by](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.groupby.html)</span><br><span class="line"></span><br><span class="line">  - 根据某些col对数据进行聚合</span><br><span class="line">  </span><br><span class="line">- ~~[as_matrix](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.as_matrix.html#pandas.DataFrame.as_matrix)~~</span><br><span class="line"></span><br><span class="line">  - 转化为numpy的数组，注意columns参数是列名的列表</span><br><span class="line"></span><br><span class="line">- [columns](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.columns.html#pandas.DataFrame.columns)</span><br><span class="line"></span><br><span class="line">  - 获取列名</span><br><span class="line"></span><br><span class="line">- 获取某个位置的元素</span><br><span class="line"></span><br><span class="line">  - [`DataFrame.iat`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iat.html#pandas.DataFrame.iat)</span><br><span class="line"></span><br><span class="line">    Fast integer location scalar accessor.</span><br><span class="line"></span><br><span class="line">  - [`DataFrame.loc`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.loc.html#pandas.DataFrame.loc)</span><br><span class="line"></span><br><span class="line">    Purely label-location based indexer for selection by label.</span><br><span class="line"></span><br><span class="line">  - [`Series.iloc`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.iloc.html#pandas.Series.iloc)</span><br><span class="line"></span><br><span class="line">    Purely integer-location based indexing for selection by position.</span><br><span class="line"></span><br><span class="line">- [values](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html)</span><br><span class="line"></span><br><span class="line">  - 返回numpy 数组值</span><br><span class="line"></span><br><span class="line">- [apply]([http://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply](http://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply))</span><br><span class="line"></span><br><span class="line">  -</span><br></pre></td></tr></table></figure></p><p>df.apply(np.sum, axis=0)<br>df.apply(lambda x: [1, 2], axis=1)<br>X[categorical_cols] = X[categorical_cols].apply(lambda col: le.fit_transform(col))<br>```</p></li></ul></li><li></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;pandas-common-usage&quot;&gt;&lt;a href=&quot;#pandas-common-usage&quot; class=&quot;headerlink&quot; title=&quot;pandas common usage&quot;&gt;&lt;/a&gt;pandas common usage&lt;/h1&gt;&lt;bloc
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Josephus Problem</title>
    <link href="http://yoursite.com/2019/01/05/Josephus-Problem/"/>
    <id>http://yoursite.com/2019/01/05/Josephus-Problem/</id>
    <published>2019-01-05T06:42:32.000Z</published>
    <updated>2019-01-12T03:13:33.218Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Josephus-Problem"><a href="#Josephus-Problem" class="headerlink" title="Josephus Problem"></a>Josephus Problem</h1><h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><blockquote><p>In <a href="https://en.wikipedia.org/wiki/Computer_science" target="_blank" rel="noopener">computer science</a> and <a href="https://en.wikipedia.org/wiki/Mathematics" target="_blank" rel="noopener">mathematics</a>, the <strong>Josephus problem</strong> (or <strong>Josephus permutation</strong>) is a theoretical problem related to a certain <a href="https://en.wikipedia.org/wiki/Counting-out_game" target="_blank" rel="noopener">counting-out game</a>.</p><p>People are standing in a <a href="https://en.wikipedia.org/wiki/Circle" target="_blank" rel="noopener">circle</a> waiting to be executed. Counting begins at a specified point in the circle and proceeds around the circle in a specified direction. After a specified number of people are skipped, the next person is executed. The procedure is repeated with the remaining people, starting with the next person, going in the same direction and skipping the same number of people, until only one person remains, and is freed.</p><p>The problem — given the number of people, starting point, direction, and number to be skipped — is to choose the position in the initial circle to avoid execution</p><p><a href="https://en.wikipedia.org/wiki/Josephus_problem" target="_blank" rel="noopener">more info</a></p><p>约瑟夫是公元一世纪著名的历史学家。在罗马人占领乔塔帕特后，39 个犹太人与约瑟夫及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人俘虏，于是决定了一个流传千古的自杀方式，41个人排成一个圆圈，由第1个人开始报数，每报到第3人该人就必须自杀，然后再由下一个人重新报数，直到所有人都自杀身亡为止。</p></blockquote><p>Josephus problem是一个非常有意思的问题，理解起来很简单，但是要解决却不是太容易。以前在程序课上接触过这个问题，当时的解决方法非常暴力，直接模拟整个游戏过程来得到最终答案。最近读到《具体数学》再次接触到了这个问题，书中的解法确有让人拍案而起的欲望。下面从该问题最基础的类型说起，一步一步解释书中的解法。</p><h2 id="基础问题"><a href="#基础问题" class="headerlink" title="基础问题"></a>基础问题</h2><ul><li><p>现有一个n节点的圆圈，且从1到n有序排列。从1开始计数，每隔一个节点去除一个节点，问最后剩下的节点（下面简称幸存者）序号是多少？</p><p><img src="/2019/01/05/Josephus-Problem/josephus example.png" alt="josephus example"></p><p style="background-color:powderblue;font-size:15px;">Figure 1 </p></li><li><p>要解决这个问题，可以从递归的角度来考虑，这一点在图1中有很直观的表达。针对我们的问题，我们要求解的是幸存者序号，不妨表示为$f(n)$，根据n的奇偶性可以得到下面的关系</p></li></ul><script type="math/tex; mode=display">\begin{align}  问题1  \begin{cases}  f(1) &=& 1\\  f(2n) &=& 2·f(n)-1\\  f(2n+1) &=& 2·f(n)+1\\  \end{cases}  \end{align}</script><p>  现在的问题是如何根据上面的关系求出$f(n)$的表达式。首先不妨从一些简单的例子观察一下规律</p><div class="table-container"><table><thead><tr><th>n</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th></tr></thead><tbody><tr><td>$f$</td><td>1</td><td>1</td><td>2</td><td>1</td><td>2</td><td>3</td><td>4</td><td>1</td></tr></tbody></table></div><p>  看起来是有一定规律的，写成下面这样也许更清晰</p><div class="table-container"><table><thead><tr><th>n</th><th>$2^0$</th><th>$2^1$</th><th>$2^1+1$</th><th>$2^2$</th><th>$2^2+1$</th><th>$2^2+2$</th><th>$2^2+3$</th><th>$2^3$</th></tr></thead><tbody><tr><td>$f$</td><td>1</td><td>1</td><td>3</td><td>1</td><td>3</td><td>5</td><td>7</td><td>1</td></tr></tbody></table></div><p>  简单的归纳就是$f(n) = 2l+1, n=2^m+l$，下面用数学归纳法来证明这一结论</p><script type="math/tex; mode=display">  \begin{align}  &需要证明：对于n=2^m+l, f(n)=2l+1,其中0=<l<2^m\\  &证明：\\  &m = 0, n = 1\ 时f(1) = 2·0+1,结论成立\\  &假设m=k时结论成立,下正m=k+1时结论仍然成立\\  &m=k+1时, 2^{k+1}=<n<2^{k+2}\\  &当n为偶数时, n = 2^{k+1} + l, l为偶数, l=2l^*\\  &f(n) = 2f(2^k+l^*)-1=2(2l^*+1)-1=2l+1\\  &n为奇数时类似,不难得出当m=k+1时结论仍成立，得证  \end{align}</script><p>  现在我们已经有了$f(n)$的显式表达，不过更令人兴奋的是我们可以用一种更为简洁美观的方式来表达这一结果。</p><script type="math/tex; mode=display">\begin{align}  &首先将n=2^m+l表示为二进制的形式, n=(b_mb_{m-1}...b_1b_0)_2,即n=b_m2^m+..+b_0\\  &其中b_m=1, l=(b_{m-1}b_{m-2}...b1b0)_2\\  &2l+1=2(b_{m-1}b_{m-2}...b1b0)_2+1=(b_{m-1}b_{m-2}...b_1b_0b_m)_2\\  &f((b_mb_{m-1}...b_1b_0)_2)=(b_{m-1}b_{m-2}...b_1b_0b_m)_2\\  &这样计算f(n)就可以用计算机最喜欢的移位运算了  \end{align}</script><p>  第一次看到上面的结果，我确实很开心，感觉这种形式很漂亮。不过让我更惊喜的是不仅在基础情况下，在复杂的情况下我们也可以利用上面的形式来求解递归式。</p><p>为了叙述简便，把递归式中$f(dn)$ 中d称为step，下面一般化以d为基础</p><h2 id="问题一般化"><a href="#问题一般化" class="headerlink" title="问题一般化"></a>问题一般化</h2><h3 id="Step-2"><a href="#Step-2" class="headerlink" title="Step=2"></a>Step=2</h3><ul><li>step=2与上面解决的问题有很大重合，问题形式化表达如下<script type="math/tex; mode=display">\begin{align}问题2  \begin{cases}  f(1) &=& \alpha\\  f(2n+j) &=& 2·f(n)+\beta_j \ \ (j=0, 1)  \end{cases}  \end{align}</script>问题2与问题1的唯一区别是对$\alpha,\beta_j$进行了一般化，在问题1中$\alpha=1,\beta_0=-1, \beta_1=1$</li></ul><script type="math/tex; mode=display">  \begin{align}  &首先将n=2^m+l表示为二进制的形式, n=(b_mb_{m-1}...b_1b_0)_2,即n=b_m2^m+..+b_0\\  &n = 1, f(1) = \alpha, f((1)_2) = \alpha\\  &对j进行分类\\  &j=0时l=2·l^*\\  &f(n)=2f(2^{m-1}+l*)+\beta_0\\  &f((b_mb_{m-1}...b_1b_0)_2)=2f((b_mb_{m-1}...b_1)_2)+\beta_0\\  &f((b_mb_{m-1}...b_1b_0)_2)=2f(b_mb_{m-1}...b_1)_2)+\beta_{b_0}\\  &j=1  时类似，递归可以得到如下结果\\  &f((b_mb_{m-1}...b_1b_0)_2)=2^m\alpha+2^{m-1}\beta_{b_{m-1}}+...+\beta_{b_0}\\  &f((b_mb_{m-1}...b_1b_0)_2)=(\alpha\beta_{b_{m-1}}...\beta_{b_0})_2  \end{align}</script><p>  可以看到，我们再次利用二进制形式写出了任意$f(n)$的解表达式。不过需要注意的是这里的二进制与一般意义上的二进制表达式有一定区别，这里在某个二进制位上的数值可能取0，1之外的值</p><h3 id="Step-d-d-gt-1"><a href="#Step-d-d-gt-1" class="headerlink" title="Step = d, d&gt;1"></a>Step = d, d&gt;1</h3><ul><li>这里对step一般化，取任意大于1的整数值，问题形式化表达如下<script type="math/tex; mode=display">\begin{align}问题3  \begin{cases}  f(j) &=& \alpha_j\ (0<j<d)\\   f(dn+j) &=& cf(n)+\beta_j \ \ (0=<j<d)  \end{cases}  \end{align}</script></li></ul><script type="math/tex; mode=display">\begin{align}&首先将n=2^m+l表示为d进制的形式, n=(b_mb_{m-1}...b_1b_0)_d,即n=b_md^m+..+b_0\\&n = j, f(j) = \alpha_j, f((j)_d) = \alpha_j, \ (0<j<d)\\&n=(b_mb_{m-1}...b_1b_0)_d, b_0=j\\&f((b_mb_{m-1}...b_1b_0)_d)=2f((b_mb_{m-1}...b_1)_2)+\beta_0\\&f((b_mb_{m-1}...b_1b_0)_d)=cf(b_mb_{m-1}...b_1)_d)+\beta_{b_0}\\&f((b_mb_{m-1}...b_1b_0)_d)=c^m\alpha_{b_m}+c^{m-1}\beta_{b_{m-1}}+...+\beta_{b_0}\\&f((b_mb_{m-1}...b_1b_0)_d)=(\alpha_{b_m}\beta_{b_{m-1}}...\beta_{b_0})_c\end{align}</script><ul><li>问题3是最一般化的形式，从最后结果来看，问题3中定义的递归表达式将一个d进制的数映射到了另一个c进        制的数</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Josephus-Problem&quot;&gt;&lt;a href=&quot;#Josephus-Problem&quot; class=&quot;headerlink&quot; title=&quot;Josephus Problem&quot;&gt;&lt;/a&gt;Josephus Problem&lt;/h1&gt;&lt;h2 id=&quot;问题引入&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="Mathematics" scheme="http://yoursite.com/tags/Mathematics/"/>
    
      <category term="Concrete Mathematics" scheme="http://yoursite.com/tags/Concrete-Mathematics/"/>
    
      <category term="Recurrent Problem" scheme="http://yoursite.com/tags/Recurrent-Problem/"/>
    
  </entry>
  
  <entry>
    <title>BurnSide&#39;s Lemma</title>
    <link href="http://yoursite.com/2018/12/30/BurnSide-Lemma/"/>
    <id>http://yoursite.com/2018/12/30/BurnSide-Lemma/</id>
    <published>2018-12-30T00:35:41.000Z</published>
    <updated>2019-01-05T08:01:32.631Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Burnside’s-lemma"><a href="#Burnside’s-lemma" class="headerlink" title="Burnside’s lemma"></a>Burnside’s lemma</h1><h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><ul><li><p>利用三种颜色给一个正三边形的顶点着色，在考虑图案重复的情况下总共有多少不同的着色方法？</p></li><li><p>上面的着色问题是一类计数问题，在计数的过程中由于需要考虑到去除重复的元素，所以问题会显得比较复杂</p><p><img src="/2018/12/30/BurnSide-Lemma/colour_symmetries.png"></p><p style="background-color:powderblue;font-size:15px;">Figure 1 </p><p>以上图为例，六种三角形的着色实际是等价的，只能算一种着色方式。</p></li></ul><h2 id="Burnside’s-lemma定义"><a href="#Burnside’s-lemma定义" class="headerlink" title="Burnside’s lemma定义"></a>Burnside’s lemma定义</h2><ul><li><blockquote><p><strong>Burnside’s lemma</strong>, sometimes also called <strong>Burnside’s counting theorem</strong>, the <strong>Cauchy–Frobenius lemma</strong>,<strong>orbit-counting theorem</strong>, or <strong>The Lemma that is not Burnside’s</strong> , is a result in <a href="https://en.wikipedia.org/wiki/Group_theory" target="_blank" rel="noopener">group theory</a> which is often useful in taking account of <a href="https://en.wikipedia.org/wiki/Symmetry" target="_blank" rel="noopener">symmetry</a> when counting mathematical objects.In the following, let <em>G</em> be a <a href="https://en.wikipedia.org/wiki/Finite_set" target="_blank" rel="noopener">finite</a> <a href="https://en.wikipedia.org/wiki/Group_(mathematics" target="_blank" rel="noopener">group</a>) that <a href="https://en.wikipedia.org/wiki/Group_action" target="_blank" rel="noopener">acts</a> on a <a href="https://en.wikipedia.org/wiki/Set_(mathematics" target="_blank" rel="noopener">set</a>) <em>X</em>. For each <em>g</em> in <em>G</em> let <em>Xg</em> denote the set of <a href="https://en.wikipedia.org/wiki/Element_(mathematics" target="_blank" rel="noopener">elements</a>) in <em>X</em> that are <a href="https://en.wikipedia.org/wiki/Fixed_point_(mathematics" target="_blank" rel="noopener">fixed by</a>) <em>g</em> (also said to be left <a href="https://en.wikipedia.org/wiki/Invariant_(mathematics" target="_blank" rel="noopener">invariant</a>) by <em>g</em>), i.e. <em>$X^g $</em> = { <em>x</em> ∈ <em>X</em> | <em>g</em>.<em>x</em> = <em>x</em> }. Burnside’s lemma asserts the following formula for the number of <a href="https://en.wikipedia.org/wiki/Orbit_(group_theory" target="_blank" rel="noopener">orbits</a>), denoted |<em>X</em>/<em>G</em>|</p>$$|X/G|={\frac  {1}{|G|}}\sum _{{g\in G}}|X^{g}|$$<p><a href="https://en.wikipedia.org/wiki/Burnside%27s_lemma" target="_blank" rel="noopener">Burnside’s lemma</a></p></blockquote></li><li><p>上面给出了Burnside’s lemma的定义，其具体的证明过程可参考给出的链接。利用Burnside’s lemma我们现在可以来试着解决一开始给出的着色问题了。</p></li></ul><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><ul><li>着色问题的形式化定义<ul><li>$X :=\{不考虑重复的所有着色图案\}$</li><li>$G :=\{对任一图案的所有变换\}$</li><li>$|X/G| := 所有不重复的着色方式总数$</li></ul></li><li>$G$ 代表了对图案的变换方式，图1实际上就包含了对三角形的所有变换方式。其中旋转变换有三种，对称变换有三种。以旋转$\frac 2 3 \pi$为例，$X^g = \{x | colorA = colorB = colorC\}$  只有满足条件的着色图案才有$g.x=x$ ，不难计算这类着色方式有三种，$3^1$</li><li>对于上述的三色三角形问题，总共有 $\frac 1 6(3^3+2·3^1+3·3^2) = 10$种着手方式</li></ul><h2 id="问题一般化"><a href="#问题一般化" class="headerlink" title="问题一般化"></a>问题一般化</h2><ul><li><p>利用上述定理可以解决任意$(n, m)$着色问题，其中n代表正多边形的顶点数，m代表颜色数。</p></li><li><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/12/30/BurnSide-Lemma/question.png" alt="question" title="">                </div>                <div class="image-caption">question</div>            </figure><p style="background-color:powderblue;font-size:15px;">Figure 2 </p><p>图2便是一个一般化的正多边形的着色问题。</p></li><li><p>解决这个一般化问题可以从两个部分入手</p><ul><li><p>旋转变换对应的$X^g$: 对于n边形，旋转变换共有n种，旋转度数从$0-2\pi$,关键问题是如何计算每一种旋转变换的着色数量。下面尝试将问题形式化</p><script type="math/tex; mode=display">\begin{align}&对于任一旋转变换d(0=< d < n),顶点可分为以下几类\\&\Phi _0 = \{0, d, 2d, ...\}\\&\Phi _1 = \{1, d+1, 2d+1, ...\}\\&...\\&\Phi _i = \{i, d+i, 2d+i, ...\}\\&对于任一顶点x, x属于并仅属于某一\Phi\\&对任一(x_1,x_2)属于\Phi_j, x_1 = x_2+kd\ (mod\ n)\\&对于同一\Phi中的顶点，颜色应该一致，总的着色数有m^{i+1}\end{align}</script></li><li><p>对称变换较容易，考虑奇偶分类处理即可</p></li></ul></li><li><p>Python代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> step <span class="keyword">in</span> range(n):</span><br><span class="line">    count = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        count[i] = <span class="number">0</span></span><br><span class="line">    uncount, ucNow, ucAll = <span class="keyword">True</span>, <span class="number">0</span>, []</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        ucFirst, orbitSet = <span class="number">0</span>, []</span><br><span class="line">        <span class="keyword">while</span> ucFirst != n:</span><br><span class="line">            <span class="keyword">if</span> count[ucFirst] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ucFirst += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> ucFirst == n:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        i = ucFirst</span><br><span class="line">        <span class="keyword">while</span> count[i] != <span class="number">1</span>:</span><br><span class="line">            orbitSet.append(i)</span><br><span class="line">            count[i] = <span class="number">1</span></span><br><span class="line">            i = (i+step)%n </span><br><span class="line">        ucNow += <span class="number">1</span></span><br><span class="line">//模拟得出所有的orbitSet集合，例如n=<span class="number">10</span>，step=<span class="number">2</span>时，orbitSet集合为</span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure><p>通过证明可以得到$|\Phi| = grd(n, d)$, 这样就不用计算每个集合的元素，直接可以得到集合个数</p><p>对称变换太简单，这里不详细说明。</p></li><li><p><a href="https://codeforces.com/blog/entry/51272" target="_blank" rel="noopener">其它类似问题</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Burnside’s-lemma&quot;&gt;&lt;a href=&quot;#Burnside’s-lemma&quot; class=&quot;headerlink&quot; title=&quot;Burnside’s lemma&quot;&gt;&lt;/a&gt;Burnside’s lemma&lt;/h1&gt;&lt;h2 id=&quot;问题引入&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="Mathematics" scheme="http://yoursite.com/tags/Mathematics/"/>
    
      <category term="GroupTheory" scheme="http://yoursite.com/tags/GroupTheory/"/>
    
      <category term="CountProblem" scheme="http://yoursite.com/tags/CountProblem/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
</feed>
