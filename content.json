{"meta":{"title":"Alephn's Blog","subtitle":"Stay hungry, stay foolish","description":null,"author":"Alephn","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"2018-12-29T12:29:30.165Z","updated":"2018-12-29T12:27:08.999Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Josephus Problem","slug":"Josephus-Problem","date":"2019-01-05T06:42:32.000Z","updated":"2019-01-12T02:36:42.178Z","comments":true,"path":"2019/01/05/Josephus-Problem/","link":"","permalink":"http://yoursite.com/2019/01/05/Josephus-Problem/","excerpt":"","text":"Josephus Problem问题引入 In computer science and mathematics, the Josephus problem (or Josephus permutation) is a theoretical problem related to a certain counting-out game. People are standing in a circle waiting to be executed. Counting begins at a specified point in the circle and proceeds around the circle in a specified direction. After a specified number of people are skipped, the next person is executed. The procedure is repeated with the remaining people, starting with the next person, going in the same direction and skipping the same number of people, until only one person remains, and is freed. The problem — given the number of people, starting point, direction, and number to be skipped — is to choose the position in the initial circle to avoid execution more info 约瑟夫是公元一世纪著名的历史学家。在罗马人占领乔塔帕特后，39 个犹太人与约瑟夫及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人俘虏，于是决定了一个流传千古的自杀方式，41个人排成一个圆圈，由第1个人开始报数，每报到第3人该人就必须自杀，然后再由下一个人重新报数，直到所有人都自杀身亡为止。 Josephus problem是一个非常有意思的问题，理解起来很简单，但是要解决却不是太容易。以前在程序课上接触过这个问题，当时的解决方法非常暴力，直接模拟整个游戏过程来得到最终答案。最近读到《具体数学》再次接触到了这个问题，书中的解法确有让人拍案而起的欲望。下面从该问题最基础的类型说起，一步一步解释书中的解法。 基础问题 现有一个n节点的圆圈，且从1到n有序排列。从1开始计数，每隔一个节点去除一个节点，问最后剩下的节点（下面简称幸存者）序号是多少？ Figure 1 要解决这个问题，可以从递归的角度来考虑，这一点在图1中有很直观的表达。针对我们的问题，我们要求解的是幸存者序号，不妨表示为$f(n)$，根据n的奇偶性可以得到下面的关系 \\begin{align} 问题1 \\begin{cases} f(1) &=& 1\\\\ f(2n) &=& 2·f(n)-1\\\\ f(2n+1) &=& 2·f(n)+1\\\\ \\end{cases} \\end{align} 现在的问题是如何根据上面的关系求出$f(n)$的表达式。首先不妨从一些简单的例子观察一下规律 n 1 2 3 4 5 6 7 8 $f$ 1 1 2 1 2 3 4 1 看起来是有一定规律的，写成下面这样也许更清晰 n $2^0$ $2^1$ $2^1+1$ $2^2$ $2^2+1$ $2^2+2$ $2^2+3$ $2^3$ $f$ 1 1 3 1 3 5 7 1 简单的归纳就是$f(n) = 2l+1, n=2^m+l$，下面用数学归纳法来证明这一结论 \\begin{align} &需要证明：对于n=2^m+l, f(n)=2l+1,其中0=","categories":[],"tags":[{"name":"Mathematics","slug":"Mathematics","permalink":"http://yoursite.com/tags/Mathematics/"},{"name":"Concrete Mathematics","slug":"Concrete-Mathematics","permalink":"http://yoursite.com/tags/Concrete-Mathematics/"},{"name":"Recurrent Problem","slug":"Recurrent-Problem","permalink":"http://yoursite.com/tags/Recurrent-Problem/"}]},{"title":"BurnSide's Lemma","slug":"BurnSide-Lemma","date":"2018-12-30T00:35:41.000Z","updated":"2019-01-05T08:01:32.631Z","comments":true,"path":"2018/12/30/BurnSide-Lemma/","link":"","permalink":"http://yoursite.com/2018/12/30/BurnSide-Lemma/","excerpt":"","text":"Burnside’s lemma问题引入 利用三种颜色给一个正三边形的顶点着色，在考虑图案重复的情况下总共有多少不同的着色方法？ 上面的着色问题是一类计数问题，在计数的过程中由于需要考虑到去除重复的元素，所以问题会显得比较复杂 Figure 1 以上图为例，六种三角形的着色实际是等价的，只能算一种着色方式。 Burnside’s lemma定义 Burnside’s lemma, sometimes also called Burnside’s counting theorem, the Cauchy–Frobenius lemma,orbit-counting theorem, or The Lemma that is not Burnside’s , is a result in group theory which is often useful in taking account of symmetry when counting mathematical objects.In the following, let G be a finite group) that acts on a set) X. For each g in G let Xg denote the set of elements) in X that are fixed by) g (also said to be left invariant) by g), i.e. $X^g $ = { x ∈ X | g.x = x }. Burnside’s lemma asserts the following formula for the number of orbits), denoted |X/G| $$|X/G|={\\frac {1}{|G|}}\\sum _{{g\\in G}}|X^{g}|$$ Burnside’s lemma 上面给出了Burnside’s lemma的定义，其具体的证明过程可参考给出的链接。利用Burnside’s lemma我们现在可以来试着解决一开始给出的着色问题了。 问题解决 着色问题的形式化定义 $X :=\\{不考虑重复的所有着色图案\\}$ $G :=\\{对任一图案的所有变换\\}$ $|X/G| := 所有不重复的着色方式总数$ $G$ 代表了对图案的变换方式，图1实际上就包含了对三角形的所有变换方式。其中旋转变换有三种，对称变换有三种。以旋转$\\frac 2 3 \\pi$为例，$X^g = \\{x | colorA = colorB = colorC\\}$ 只有满足条件的着色图案才有$g.x=x$ ，不难计算这类着色方式有三种，$3^1$ 对于上述的三色三角形问题，总共有 $\\frac 1 6(3^3+2·3^1+3·3^2) = 10$种着手方式 问题一般化 利用上述定理可以解决任意$(n, m)$着色问题，其中n代表正多边形的顶点数，m代表颜色数。 question Figure 2 图2便是一个一般化的正多边形的着色问题。 解决这个一般化问题可以从两个部分入手 旋转变换对应的$X^g$: 对于n边形，旋转变换共有n种，旋转度数从$0-2\\pi$,关键问题是如何计算每一种旋转变换的着色数量。下面尝试将问题形式化 \\begin{align} &对于任一旋转变换d(0=< d < n),顶点可分为以下几类\\\\ &\\Phi _0 = \\{0, d, 2d, ...\\}\\\\ &\\Phi _1 = \\{1, d+1, 2d+1, ...\\}\\\\ &...\\\\ &\\Phi _i = \\{i, d+i, 2d+i, ...\\}\\\\ &对于任一顶点x, x属于并仅属于某一\\Phi\\\\ &对任一(x_1,x_2)属于\\Phi_j, x_1 = x_2+kd\\ (mod\\ n)\\\\ &对于同一\\Phi中的顶点，颜色应该一致，总的着色数有m^{i+1} \\end{align} 对称变换较容易，考虑奇偶分类处理即可 Python代码 1234567891011121314151617181920212223for step in range(n): count = &#123;&#125; for i in range(n): count[i] = 0 uncount, ucNow, ucAll = True, 0, [] while True: ucFirst, orbitSet = 0, [] while ucFirst != n: if count[ucFirst] == 0: break else: ucFirst += 1 if ucFirst == n: break i = ucFirst while count[i] != 1: orbitSet.append(i) count[i] = 1 i = (i+step)%n ucNow += 1//模拟得出所有的orbitSet集合，例如n=10，step=2时，orbitSet集合为[0, 2, 4, 6, 8][1, 3, 5, 7, 9] 通过证明可以得到$|\\Phi| = grd(n, d)$, 这样就不用计算每个集合的元素，直接可以得到集合个数 对称变换太简单，这里不详细说明。 其它类似问题","categories":[],"tags":[{"name":"Mathematics","slug":"Mathematics","permalink":"http://yoursite.com/tags/Mathematics/"},{"name":"GroupTheory","slug":"GroupTheory","permalink":"http://yoursite.com/tags/GroupTheory/"},{"name":"CountProblem","slug":"CountProblem","permalink":"http://yoursite.com/tags/CountProblem/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]}]}