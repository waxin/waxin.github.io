{"meta":{"title":"Alephn's Blog","subtitle":"Stay hungry, stay foolish","description":null,"author":"Alephn","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"2018-12-29T12:29:30.165Z","updated":"2018-12-29T12:27:08.999Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"BurnSide's Lemma","slug":"BurnSide-Lemma","date":"2018-12-30T00:35:41.000Z","updated":"2019-01-01T06:40:34.277Z","comments":true,"path":"2018/12/30/BurnSide-Lemma/","link":"","permalink":"http://yoursite.com/2018/12/30/BurnSide-Lemma/","excerpt":"","text":"Burnside’s lemma问题引入 利用三种颜色给一个正三边形的顶点着色，在考虑图案重复的情况下总共有多少不同的着色方法？ 上面的着色问题是一类计数问题，在计数的过程中由于需要考虑到去除重复的元素，所以问题会显得比较复杂 Figure 1 以上图为例，六种三角形的着色实际是等价的，只能算一种着色方式。 Burnside’s lemma定义 Burnside’s lemma, sometimes also called Burnside’s counting theorem, the Cauchy–Frobenius lemma,orbit-counting theorem, or The Lemma that is not Burnside’s , is a result in group theory which is often useful in taking account of symmetry when counting mathematical objects.In the following, let G be a finite group) that acts on a set) X. For each g in G let Xg denote the set of elements) in X that are fixed by) g (also said to be left invariant) by g), i.e. $X^g $ = { x ∈ X | g.x = x }. Burnside’s lemma asserts the following formula for the number of orbits), denoted |X/G| $$|X/G|={\\frac {1}{|G|}}\\sum _{{g\\in G}}|X^{g}|$$ Burnside’s lemma 上面给出了Burnside’s lemma的定义，其具体的证明过程可参考给出的链接。利用Burnside’s lemma我们现在可以来试着解决一开始给出的着色问题了。 问题解决 着色问题的形式化定义 $X :=\\{不考虑重复的所有着色图案\\}$ $G :=\\{对任一图案的所有变换\\}$ $|X/G| := 所有不重复的着色方式总数$ $G$ 代表了对图案的变换方式，图1实际上就包含了对三角形的所有变换方式。其中旋转变换有三种，对称变换有三种。以旋转$\\frac 2 3 \\pi$为例，$X^g = \\{x | colorA = colorB = colorC\\}$ 只有满足条件的着色图案才有$g.x=x$ ，不难计算这类着色方式有三种，$3^1$ 对于上述的三色三角形问题，总共有 $\\frac 1 6(3^3+23^1+33^2) = 10$种着手方式 问题一般化 利用上述定理可以解决任意$(n, m)$着色问题，其中n代表正多边形的顶点数，m代表颜色数。 question Figure 2 图2便是一个一般化的正多边形的着色问题。 解决这个一般化问题可以从两个部分入手 旋转变换对应的$X^g$: 对于n边形，旋转变换共有n种，旋转度数从$0-2\\pi$,关键问题是如何计算每一种旋转变换的着色数量。下面尝试将问题形式化 \\begin{align} &对于任一旋转变换d(0=< d < n),顶点可分为以下几类\\\\ &\\Phi _0 = \\{0, d, 2d, ...\\}\\\\ &\\Phi _1 = \\{1, d+1, 2d+1, ...\\}\\\\ &...\\\\ &\\Phi _i = \\{i, d+i, 2d+i, ...\\}\\\\ &对于任一顶点x, x属于并仅属于某一\\Phi\\\\ &对任一(x_1,x_2)属于\\Phi_j, x_1 = x_2+kd\\ (mod\\ n)\\\\ &对于同一\\Phi中的顶点，颜色应该一致，总的着色数有m^{i+1} \\end{align} 对称变换较容易，考虑奇偶分类处理即可 Python代码 1234567891011121314151617181920212223for step in range(n): count = &#123;&#125; for i in range(n): count[i] = 0 uncount, ucNow, ucAll = True, 0, [] while True: ucFirst, orbitSet = 0, [] while ucFirst != n: if count[ucFirst] == 0: break else: ucFirst += 1 if ucFirst == n: break i = ucFirst while count[i] != 1: orbitSet.append(i) count[i] = 1 i = (i+step)%n ucNow += 1//模拟得出所有的orbitSet集合，例如n=10，step=2时，orbitSet集合为[0, 2, 4, 6, 8][1, 3, 5, 7, 9] 通过证明可以得到$|\\Phi| = grd(n, d)$, 这样就不用计算每个集合的元素，直接可以得到集合个数 对称变换太简单，这里不详细说明。 其它类似问题","categories":[],"tags":[{"name":"Mathematics","slug":"Mathematics","permalink":"http://yoursite.com/tags/Mathematics/"},{"name":"GroupTheory","slug":"GroupTheory","permalink":"http://yoursite.com/tags/GroupTheory/"},{"name":"CountProblem","slug":"CountProblem","permalink":"http://yoursite.com/tags/CountProblem/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]}]}