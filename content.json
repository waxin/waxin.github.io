{"meta":{"title":"Alephn's Blog","subtitle":"Stay hungry, stay foolish","description":null,"author":"Alephn","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"2018-12-29T12:29:30.165Z","updated":"2018-12-29T12:27:08.999Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"sklearn common usage","slug":"sklearn-common-usage","date":"2019-06-23T01:41:02.000Z","updated":"2019-06-24T07:11:33.899Z","comments":true,"path":"2019/06/23/sklearn-common-usage/","link":"","permalink":"http://yoursite.com/2019/06/23/sklearn-common-usage/","excerpt":"","text":"sklearn common usage本文主要记录使用sklearn中遇到的一些常见用法 scikit-learn Preprocessing SimpleImputer 123from sklearn.impute import SimpleImputerimp_mean = SimpleImputer(missing_values=np.nan, strategy='mean')imp_mean.fit_transform([[7, 2, 3], [4, np.nan, 6], [10, 5, 9]]) OneHotEncoder&amp;LabelEncoder 1234from sklearn.preprocessing import OneHotEncoderenc = OneHotEncoder(handle_unknown=&apos;ignore&apos;)X = [[&apos;Male&apos;, 1], [&apos;Female&apos;, 3], [&apos;Female&apos;, 2]]enc.fit_transform(X) 123from sklearn.preprocessing import LabelEncoderle = LabelEncoder()le.fit_transform([1, 2, 2, 6]) 一般在使用onehot之前先使用labelencoder进行处理，见例子1,例子2 Model selection and evaluation train_test_split 12from sklearn.model_selection import train_test_splitX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.33, random_state=42) StandardScaler The standard score of a sample x is calculated as: z = (x - u) / s 123from sklearn.preprocessing import StandardScalerscaler = StandardScaler()scaler.fit_transform(X) Regression LinearRegression 123from sklearn.linear_model import LinearRegressionreg = LinearRegression().fit(X, y)reg.predict(np.array([[3, 5]]))","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"Stationarity of time series","slug":"Stationarity-of-time-series","date":"2019-06-15T02:22:40.000Z","updated":"2019-06-15T03:01:26.275Z","comments":true,"path":"2019/06/15/Stationarity-of-time-series/","link":"","permalink":"http://yoursite.com/2019/06/15/Stationarity-of-time-series/","excerpt":"","text":"Stationarity of time series本文主要记录学习过程中关于时间序列平稳性的一些相关内容，包括平稳性的定义以及检测 平稳性定义 平稳性 在实际应用过程中，我们一般通过弱平稳来检测平稳性 上图来自知乎 平稳性检测123456789101112131415161718192021222324from statsmodels.tsa.stattools import adfullerdef test_stationarity(timeseries): #Determing rolling statistics rolmean = timeseries.rolling(12).mean() rolstd = timeseries.rolling(12).std() #Plot rolling statistics: orig = plt.plot(timeseries, color='blue',label='Original') mean = plt.plot(rolmean, color='red', label='Rolling Mean') std = plt.plot(rolstd, color='black', label = 'Rolling Std') plt.legend(loc='best') plt.title('Rolling Mean &amp; Standard Deviation') plt.show(block=False) #Perform Dickey-Fuller test: print ('Results of Dickey-Fuller Test:') dftest = adfuller(timeseries, autolag='AIC') dfoutput = pd.Series(dftest[0:4], index=['Test Statistic','p-value','#Lags Used','Number of Observations Used']) for key,value in dftest[4].items(): dfoutput['Critical Value (%s)'%key] = value print (dfoutput)test_stationarity(ts) 平稳性检测 利用adfuller检测时间序列平稳性，当Test Statistic小于某个Critical Value时则认为在该置信下认为时间序列平稳 时间序列平稳化差分&amp;去除趋势","categories":[],"tags":[{"name":"Statics","slug":"Statics","permalink":"http://yoursite.com/tags/Statics/"}]},{"title":"pandas common usage","slug":"pandas-common-usage","date":"2019-06-10T11:24:30.000Z","updated":"2019-06-24T07:11:35.521Z","comments":true,"path":"2019/06/10/pandas-common-usage/","link":"","permalink":"http://yoursite.com/2019/06/10/pandas-common-usage/","excerpt":"","text":"pandas common usage pandas is an open source, BSD-licensed library providing high-performance, easy-to-use data structures and data analysis tools for the Python programming language. pandas 本文主要记录在实践中遇到的一些常见的用法 一些说明 df表示pandas.DataFrame dataFrame rolling 为了提升数据的准确性，将某个点的取值扩大到包含这个点的一段区间，用区间来进行判断，这个区间就是窗口。移动窗口就是窗口向一端滑行，默认是从右往左 rolling返回的类可以进行很多数值操作，例如std(), sum()```,这些均是dataFrame包含的方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950- [dropna](https://pandas.pydata.org/pandas-docs/version/0.21/generated/pandas.DataFrame.dropna.html#pandas.DataFrame.dropna) - 去除空值- [Merge, join, and concatenate](https://pandas.pydata.org/pandas-docs/stable/user_guide/merging.html) - 对多个dataframe进行合并操作，包括行、列数据- [duplicated](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.duplicated.html) - 判断重复数据- [drop_duplicates](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.drop_duplicates.html) - ​ 去除重复数据- [group_by](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.groupby.html) - 根据某些col对数据进行聚合 - ~~[as_matrix](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.as_matrix.html#pandas.DataFrame.as_matrix)~~ - 转化为numpy的数组，注意columns参数是列名的列表- [columns](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.columns.html#pandas.DataFrame.columns) - 获取列名- 获取某个位置的元素 - [`DataFrame.iat`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iat.html#pandas.DataFrame.iat) Fast integer location scalar accessor. - [`DataFrame.loc`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.loc.html#pandas.DataFrame.loc) Purely label-location based indexer for selection by label. - [`Series.iloc`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.iloc.html#pandas.Series.iloc) Purely integer-location based indexing for selection by position.- [values](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html) - 返回numpy 数组值- [apply]([http://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply](http://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply)) - df.apply(np.sum, axis=0)df.apply(lambda x: [1, 2], axis=1)X[categorical_cols] = X[categorical_cols].apply(lambda col: le.fit_transform(col))```","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Josephus Problem","slug":"Josephus-Problem","date":"2019-01-05T06:42:32.000Z","updated":"2019-01-12T03:13:33.218Z","comments":true,"path":"2019/01/05/Josephus-Problem/","link":"","permalink":"http://yoursite.com/2019/01/05/Josephus-Problem/","excerpt":"","text":"Josephus Problem问题引入 In computer science and mathematics, the Josephus problem (or Josephus permutation) is a theoretical problem related to a certain counting-out game. People are standing in a circle waiting to be executed. Counting begins at a specified point in the circle and proceeds around the circle in a specified direction. After a specified number of people are skipped, the next person is executed. The procedure is repeated with the remaining people, starting with the next person, going in the same direction and skipping the same number of people, until only one person remains, and is freed. The problem — given the number of people, starting point, direction, and number to be skipped — is to choose the position in the initial circle to avoid execution more info 约瑟夫是公元一世纪著名的历史学家。在罗马人占领乔塔帕特后，39 个犹太人与约瑟夫及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人俘虏，于是决定了一个流传千古的自杀方式，41个人排成一个圆圈，由第1个人开始报数，每报到第3人该人就必须自杀，然后再由下一个人重新报数，直到所有人都自杀身亡为止。 Josephus problem是一个非常有意思的问题，理解起来很简单，但是要解决却不是太容易。以前在程序课上接触过这个问题，当时的解决方法非常暴力，直接模拟整个游戏过程来得到最终答案。最近读到《具体数学》再次接触到了这个问题，书中的解法确有让人拍案而起的欲望。下面从该问题最基础的类型说起，一步一步解释书中的解法。 基础问题 现有一个n节点的圆圈，且从1到n有序排列。从1开始计数，每隔一个节点去除一个节点，问最后剩下的节点（下面简称幸存者）序号是多少？ Figure 1 要解决这个问题，可以从递归的角度来考虑，这一点在图1中有很直观的表达。针对我们的问题，我们要求解的是幸存者序号，不妨表示为$f(n)$，根据n的奇偶性可以得到下面的关系 \\begin{align} 问题1 \\begin{cases} f(1) &=& 1\\\\ f(2n) &=& 2·f(n)-1\\\\ f(2n+1) &=& 2·f(n)+1\\\\ \\end{cases} \\end{align} 现在的问题是如何根据上面的关系求出$f(n)$的表达式。首先不妨从一些简单的例子观察一下规律 n 1 2 3 4 5 6 7 8 $f$ 1 1 2 1 2 3 4 1 看起来是有一定规律的，写成下面这样也许更清晰 n $2^0$ $2^1$ $2^1+1$ $2^2$ $2^2+1$ $2^2+2$ $2^2+3$ $2^3$ $f$ 1 1 3 1 3 5 7 1 简单的归纳就是$f(n) = 2l+1, n=2^m+l$，下面用数学归纳法来证明这一结论 \\begin{align} &需要证明：对于n=2^m+l, f(n)=2l+1,其中0=","categories":[],"tags":[{"name":"Mathematics","slug":"Mathematics","permalink":"http://yoursite.com/tags/Mathematics/"},{"name":"Concrete Mathematics","slug":"Concrete-Mathematics","permalink":"http://yoursite.com/tags/Concrete-Mathematics/"},{"name":"Recurrent Problem","slug":"Recurrent-Problem","permalink":"http://yoursite.com/tags/Recurrent-Problem/"}]},{"title":"BurnSide's Lemma","slug":"BurnSide-Lemma","date":"2018-12-30T00:35:41.000Z","updated":"2019-01-05T08:01:32.631Z","comments":true,"path":"2018/12/30/BurnSide-Lemma/","link":"","permalink":"http://yoursite.com/2018/12/30/BurnSide-Lemma/","excerpt":"","text":"Burnside’s lemma问题引入 利用三种颜色给一个正三边形的顶点着色，在考虑图案重复的情况下总共有多少不同的着色方法？ 上面的着色问题是一类计数问题，在计数的过程中由于需要考虑到去除重复的元素，所以问题会显得比较复杂 Figure 1 以上图为例，六种三角形的着色实际是等价的，只能算一种着色方式。 Burnside’s lemma定义 Burnside’s lemma, sometimes also called Burnside’s counting theorem, the Cauchy–Frobenius lemma,orbit-counting theorem, or The Lemma that is not Burnside’s , is a result in group theory which is often useful in taking account of symmetry when counting mathematical objects.In the following, let G be a finite group) that acts on a set) X. For each g in G let Xg denote the set of elements) in X that are fixed by) g (also said to be left invariant) by g), i.e. $X^g $ = { x ∈ X | g.x = x }. Burnside’s lemma asserts the following formula for the number of orbits), denoted |X/G| $$|X/G|={\\frac {1}{|G|}}\\sum _{{g\\in G}}|X^{g}|$$ Burnside’s lemma 上面给出了Burnside’s lemma的定义，其具体的证明过程可参考给出的链接。利用Burnside’s lemma我们现在可以来试着解决一开始给出的着色问题了。 问题解决 着色问题的形式化定义 $X :=\\{不考虑重复的所有着色图案\\}$ $G :=\\{对任一图案的所有变换\\}$ $|X/G| := 所有不重复的着色方式总数$ $G$ 代表了对图案的变换方式，图1实际上就包含了对三角形的所有变换方式。其中旋转变换有三种，对称变换有三种。以旋转$\\frac 2 3 \\pi$为例，$X^g = \\{x | colorA = colorB = colorC\\}$ 只有满足条件的着色图案才有$g.x=x$ ，不难计算这类着色方式有三种，$3^1$ 对于上述的三色三角形问题，总共有 $\\frac 1 6(3^3+2·3^1+3·3^2) = 10$种着手方式 问题一般化 利用上述定理可以解决任意$(n, m)$着色问题，其中n代表正多边形的顶点数，m代表颜色数。 question Figure 2 图2便是一个一般化的正多边形的着色问题。 解决这个一般化问题可以从两个部分入手 旋转变换对应的$X^g$: 对于n边形，旋转变换共有n种，旋转度数从$0-2\\pi$,关键问题是如何计算每一种旋转变换的着色数量。下面尝试将问题形式化 \\begin{align} &对于任一旋转变换d(0=< d < n),顶点可分为以下几类\\\\ &\\Phi _0 = \\{0, d, 2d, ...\\}\\\\ &\\Phi _1 = \\{1, d+1, 2d+1, ...\\}\\\\ &...\\\\ &\\Phi _i = \\{i, d+i, 2d+i, ...\\}\\\\ &对于任一顶点x, x属于并仅属于某一\\Phi\\\\ &对任一(x_1,x_2)属于\\Phi_j, x_1 = x_2+kd\\ (mod\\ n)\\\\ &对于同一\\Phi中的顶点，颜色应该一致，总的着色数有m^{i+1} \\end{align} 对称变换较容易，考虑奇偶分类处理即可 Python代码 1234567891011121314151617181920212223for step in range(n): count = &#123;&#125; for i in range(n): count[i] = 0 uncount, ucNow, ucAll = True, 0, [] while True: ucFirst, orbitSet = 0, [] while ucFirst != n: if count[ucFirst] == 0: break else: ucFirst += 1 if ucFirst == n: break i = ucFirst while count[i] != 1: orbitSet.append(i) count[i] = 1 i = (i+step)%n ucNow += 1//模拟得出所有的orbitSet集合，例如n=10，step=2时，orbitSet集合为[0, 2, 4, 6, 8][1, 3, 5, 7, 9] 通过证明可以得到$|\\Phi| = grd(n, d)$, 这样就不用计算每个集合的元素，直接可以得到集合个数 对称变换太简单，这里不详细说明。 其它类似问题","categories":[],"tags":[{"name":"Mathematics","slug":"Mathematics","permalink":"http://yoursite.com/tags/Mathematics/"},{"name":"GroupTheory","slug":"GroupTheory","permalink":"http://yoursite.com/tags/GroupTheory/"},{"name":"CountProblem","slug":"CountProblem","permalink":"http://yoursite.com/tags/CountProblem/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]}]}